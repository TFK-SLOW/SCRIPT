
gg.setVisible(false)
PN = "com.olzhas.carparking.multyplayer2"
GN = "Car Parking 2"
GB = nil
liby = nil
libz = nil
game = gg.getTargetInfo()
P = game.processName
FP = game.name
L = gg.getTargetInfo().label
M = gg.getTargetInfo()["label"]
V = game.versionName
TP = gg.getTargetPackage()
gg.toast("ğ•ğğ«ğ­ğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§")
gg.sleep(1000)
if L == GN then
gg.toast("â£ Game : " .. L)
gg.clearResults()
gg.clearList()
else
gg.alert("âš ï¸ğˆğ§ğœğ¨ğ«ğ«ğğœğ­ ğğ«ğ¨ğœğğ¬ğ¬ ğ’ğğ¥ğğœğ­ğ¢ğ¨ğ§âš ï¸")
gg.setVisible(true)
print("ğŸš«ğ…ğšğ¢ğ¥ğğ ğğ«ğ¨ğœğğ¬ğ¬ğŸš«")
os.exit()
end
gg.sleep(1000)
if TP == PN then
gg.toast("â£ Package :" .. P)
gg.clearResults()
else
gg.alert("âš ï¸ğğšğœğ¤ğšğ ğ ğˆğ§ğœğ¨ğ«ğ«ğğœğ­âš ï¸")
gg.setVisible(true)
print("ğŸš«ğğšğœğ¤ğšğ ğ ğ„ğ«ğ«ğ¨ğ«ğŸš«")
os.exit()
end





userMode = 2 -- 1 = Developer mode, 2 = user mode

gg.alert("ğ”ğğƒğ€ğ“ğ„:\n\n â—ğğğ“ğˆğŒğˆğ™ğ„ ğğ ğğ”ğŒğğ„ğ‘\n â”— ğ„ğ€ğ’ğ˜ ğˆğğ’ğ“ğ€ğ‹ğ‹\n â”— ğ‹ğğ–ğ„ğ‘ ğ‘ğ€ğŒ ğ”ğ’ğ€ğ†ğ„\n\n â—ğğğ“ğˆğŒğˆğ™ğ„ ğğ”ğ˜ ğ‚ğ€ğ‘ğ’ ğğğ“ğˆğğ\n â”—ğğğ“ğˆğŒğˆğ™ğ„ğƒ ğ…ğğ‘ ğ…ğğ‘ ğ‹ğğ–ğ„ğ‘ ğ‘ğ€ğŒ ğ”ğ’ğ€ğ†ğ„\n\nâ—ğ…ğ‘ğ„ğ„ ğğğƒğ˜ ğŠğˆğ“ğ’\n â”—ğ˜ğğ” ğ‚ğ€ğ ğğğ– ğˆğğğ”ğ“ ğ‚ğ”ğ’ğ“ğğŒ ğ•ğ€ğ‹ğ”ğ„ğ’\n â”—ğğğ“ğˆğŒğˆğ™ğ„ğƒ ğ…ğğ‘ ğ‹ğğ–ğ„ğ‘ ğ‘ğ€ğŒ ğ”ğ’ğ€ğ†ğ„")

gg.setVisible(false)
function mainMenu()
gg.setVisible(false)
fmenu = gg.choice({
   "ã€ğŸ’°ã€ğŒğğğ„ğ˜",    ---1
   "ã€ğŸ”§ã€ğŒğ€ğˆğğ“ğ„ğğ€ğğ‚ğ„",    ---2
   "ã€ğŸ”“ã€ğ”ğğ‹ğğ‚ğŠ ğŒğ„ğğ”",    ---3
   "ã€ğŸ¥µã€ğğ˜ğğ€ğ’ğ’ ğŒğ„ğğ”",   ---4
   "ã€â³ã€ğ’ğ‡ğˆğ…ğ“ ğ“ğˆğŒğ„ ğŒğ„ğğ”",   ---5
   "ã€ğŸã€ğƒğ˜ğğ ğ“ğ”ğğ„ ğ”ğ",     ----6
   "ã€ğŸ”¨ã€ğ“ğ”ğğğˆğğ† ğ’ğ„ğ‘ğ•ğˆğ‚ğ„",    ----7
   "ã€âš–ï¸ã€ğ„ğƒğˆğ“ ğŒğ€ğ’ğ’",   ---8
   "ã€ğŸ˜ˆã€ğğ‘ğ€ğğŠ ğŒğ„ğğ”",   ----9
   "ã€ğŸ‘‘ã€ğ€ğ‚ğ‡ğˆğ•ğ„ğŒğ„ğğ“",   ---10
   "ã€ğŸ˜‡ã€ğğ“ğ‡ğ„ğ‘ğ’",   ---11
"ğŸ”šğ„ğ—ğˆğ“" },nil,"ğ’ğ‚ğ‘ğˆğğ“ ğğ˜ ğ’ğ‹ğğ–ğ‚ğğŒâ¬…ï¸,ğŸ”’ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒğŸ”’ğŸ”’ \ná´„á´€Ê€ á´˜á´€Ê€á´‹ÉªÉ´É¢ á´á´œÊŸá´›Éªá´˜ÊŸá´€Êá´‡Ê€ 2\n"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

if fmenu == nil then 
   goto men
end
if fmenu == 1 then
    money()
end
if fmenu == 2 then 
    maintenance()
end 
if fmenu == 3 then
    unlockmenu()
end
if fmenu == 4 then
   ACKA01=gg.getRangesList('libil2cpp.so')[2].start
   SLOW=nil  SLOW={}
   SLOW[1]={}
   SLOW[1].address=ACKA01+0X335B818+0
   SLOW[1].value='D2800000h'
   SLOW[1].flags=4
   SLOW[2]={}
   SLOW[2].address=ACKA01+0X335B818+4
   SLOW[2].value='D65F03C0h'
   SLOW[2].flags=4
   gg.setValues(SLOW)
	bypass()
end
if fmenu == 5 then
    shifttime()
end
if fmenu == 6 then
    dynotune()
end
if fmenu == 7 then
   tuning()
end
if fmenu == 8 then
   EditMass()
end
if fmenu == 9 then
   prank()
end
if fmenu == 10 then
   achivement()
end
if fmenu == 11 then
   others()
end
if fmenu == 12 then
      print("â”â”â”â”â”â”â”â”â”à¼»ğŸ‡µğŸ‡­à¼ºâ”â”â”â”â”â”â”â”â”“\n        âš ï¸ğ’ğ‚ğ‘ğˆğğ“ ğğ˜ ğ’ğ‹ğğ– ğ‚ğğŒâš ï¸\nâ”—â”â”â”â”â”â”â”â”à¼»ğŸ‡µğŸ‡­à¼ºâ”â”â”â”â”â”â”â”â”›\nğğ–ğğ„ğ‘ : ğ’ğ‹ğğ– ğ‚ğğŒ\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğ†ğ€ğŒğ„ ğğ€ğŒğ„ : " .. gg.getTargetInfo()["label"] .. " \nğ•ğ„ğ‘ğ’ğˆğğ : " .. gg.getTargetInfo()["versionName"] .. " [" .. gg.getTargetInfo()["versionCode"] .. "]\nğ’ğ‚ğ‘ğˆğğ“ ğ•ğ„ğ‘ğ’ğˆğğ : ğŸ.ğŸ.ğŸ.ğŸğŸ“ğŸ“ğŸ“ğŸ–ğŸğŸ”ğŸ’ \nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"..os.date('â˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n \nğ’ğğ„ğ‚ğˆğ€ğ‹ ğ“ğ‡ğ€ğğŠğ’ ğ“ğ ğ…ğğ‘ ğ“ğ‡ğ„ğˆğ‘ ğğğ„ğ ğ’ğğ”ğ‘ğ‚ğ„ ğ“ğğğ‹ğ’ ğ…ğğ‘ ğ†ğ€ğŒğ„ ğ†ğ”ğ€ğ‘ğƒğˆğ€ğ: \nâ€¢ğ‡ğšğœğ¤ğğ«ğ¬_ğ‡ğ¨ğ®ğ¬ğ_ğ˜ğ“ \nâ€¢ğ€ğğ„ğ— ğ†ğ†\n\nğ’ğğ„ğ‚ğˆğ€ğ‹ ğ“ğ‡ğ€ğğŠğ’ ğ…ğğ‘ ğ“ğ‡ğ„ ğğ„ğğğ‹ğ„ ğ–ğ‡ğ ğ‡ğ„ğ‹ğ ğŒğ€ğŠğ„ ğ“ğ‡ğ„ ğ’ğ‚ğ‘ğˆğğ“:\nâ€¢ğƒğ‘ğ€ğ†\nâ€¢ğğ‘ğğ†ğ‘ğ€ğŒ ğğ„ğ“ğ€ '))
      os.exit()
   end
   ::men::
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function money()
   mny = gg.choice({
      "ğŒğğğ„ğ˜ ",
      "ğ’ğ„ğğƒ ğŒğğğ„ğ˜ ",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

   if mny == nil then
      goto mnyy
   end
   if mny == 1 then
      ACKA01=gg.getRangesList('libil2cpp.so')[2].start
      APEX=nil  APEX={}
      APEX[1]={}
      APEX[1].address=ACKA01+0x3285338+0
      APEX[1].value='529FFFE0h'
      APEX[1].flags=4
      APEX[2]={}
      APEX[2].address=ACKA01+0x3285338+4
      APEX[2].value='72AFFFE0h'
      APEX[2].flags=4
      APEX[3]={}
      APEX[3].address=ACKA01+0x3285338+8
      APEX[3].value='D65F03C0h'
      APEX[3].flags=4
      gg.setValues(APEX)
      gg.alert("ğğ")
   end
   if mny == 2 then
      ACKA01=gg.getRangesList('libil2cpp.so')[2].start
      APEX=nil  APEX={}
      APEX[1]={}
      APEX[1].address=ACKA01+0x324C158+0
      APEX[1].value='D2800020h'
      APEX[1].flags=4
      APEX[2]={}
      APEX[2].address=ACKA01+0x324C158+4
      APEX[2].value='D65F03C0h'
      APEX[2].flags=4
      gg.setValues(APEX)
      gg.alert("ğğ")
   end
   if mny == 3 then
      mainMenu()
   end
   ::mnyy::
end


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



function maintenance()
   mainte = gg.choice({
      "ğğˆğ‹ ğ‚ğğğƒğˆğ“ğˆğğ",
      "ğ…ğ”ğ„ğ‹ ğ“ğ€ğğŠ",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

   if mainte == nil then
      goto maintee
   end
   if mainte == 1 then
   local bm = gg.prompt({"ğ˜ğğ”ğ‘ ğğˆğ‹ ğ‚ğğğƒğˆğ“ğˆğğ"}, nil, {"number"})
      if bm == nil then
        gg.toast("ğ‚ğ€ğğ‚ğ„ğ‹ğ‹ğ„ğƒ")
        return
      end
      valueFromClass("MaintenanceData", "0x14", false, false, gg.TYPE_FLOAT)
      gg.refineNumber(bm[1], gg.TYPE_FLOAT)
      gg.getResults(999)
      gg.editAll(99999999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   if mainte ==  2 then 
      valueFromClass("MaintenanceData", "0x10", false, false, gg.TYPE_FLOAT)
      gg.refineNumber('0~100', gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   if mainte == 3 then
      mainMenu()
   end
   ::maintee::
end



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



function unlockmenu()
   unlockm = gg.choice({
      "ğ‚ğ€ğ‘ğ’",
      "ğ‡ğğ”ğ’ğ„",
      "ğğ€ğˆğğ“ ğ€ğğƒ ğğ‘ğ€ğŠğ„ğ’",
      "ğ€ğğˆğŒğ€ğ“ğˆğğ",
      "ğ‘ğˆğŒğ’",
      "ğ‚ğ‡ğ€ğ‘ğ€ğ‚ğ“ğ„ğ‘ğ’",
      "ğğğƒğ˜ ğŠğˆğ“ğ’",
      "ğ…ğ‘ğ„ğ„ ğ‹ğˆğ•ğ„ğ‘ğ˜",
      "ğ’ğ‹ğğ“ğ’",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))
   
   if unlockm == nil then
      goto unlockmm
   end
   if unlockm == 1 then
      gg.setVisible(false)
      gg.alert("ğğ‹ğ„ğ€ğ’ğ„ ğ–ğ€ğˆğ“","ğğŠ")
      valueFromClass("CarDefaultTuningData", "0x30", false, false, gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll("0x-4", gg.TYPE_DWORD)      
	  gg.clearResults()
      gg.alert("ğƒğğğ„","ğğŠ") 
   end
   if unlockm == 2 then
      valueFromClass("HomeData", "0x10", false, false, gg.TYPE_DWORD)
      gg.refineNumber('1000000000~3000000000', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll("0x4", gg.TYPE_DWORD)
      gg.clearResults()
      gg.clearList()
      valueFromClass("HomeData", "0x18", false, false, gg.TYPE_DWORD)
      gg.refineNumber('1000000000~3000000000', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll("0x4", gg.TYPE_DWORD)
      gg.clearResults()
      gg.clearList()
      gg.alert("ğğ")
      stopClose()
   end
   if unlockm == 3 then
      local originalValues = {}
      gg.setVisible(false)
      gg.clearResults()
      gg.setRanges(gg.REGION_ANONYMOUS)
      gg.searchNumber('1000 X4', gg.TYPE_DWORD)
  gg.refineNumber('1000000000~3000000000', gg.TYPE_DWORD)
  local results = gg.getResults(999)
  gg.editAll('0', gg.TYPE_DWORD)
  
  for _, v in ipairs(results) do
      table.insert(originalValues, v)
      local nearbyValues = gg.getValues({
          {address = v.address - 4, flags = gg.TYPE_DWORD}, -- Pegando o valor no endereÃ§o v.address - 4
      })
  
      for _, nv in ipairs(nearbyValues) do
          if nv.value == 1 then
              nv.value = 0
              gg.setValues({nv})
              gg.addListItems({nv})
          end
      end
  
      gg.setValues({{address = v.address - 4, flags = gg.TYPE_DWORD, value = 0}})
   end
  
   gg.clearResults()
   gg.clearList()
   gg.alert("ğğ")
   end
   if unlockm == 4 then
      valueFromClass("AnimationInfo", "0x20", true, false, gg.TYPE_DWORD)
      gg.refineNumber('20~500', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll(0, gg.TYPE_DWORD)
      gg.clearResults()
      gg.clearList()
      gg.alert("ğğ")
      stopClose()
   end 
   if unlockm == 5 then
      local originalValues = {}
      gg.setVisible(false)
      gg.clearResults()
      gg.setRanges(gg.REGION_ANONYMOUS)
      gg.searchNumber('100 X4', gg.TYPE_DWORD)
  gg.refineNumber('1000000000~3000000000', gg.TYPE_DWORD)
  local results = gg.getResults(999)
  gg.editAll('0', gg.TYPE_DWORD)
  
  for _, v in ipairs(results) do
      table.insert(originalValues, v)
      local nearbyValues = gg.getValues({
          {address = v.address - 4, flags = gg.TYPE_DWORD}, -- Pegando o valor no endereÃ§o v.address - 4
      })
  
      for _, nv in ipairs(nearbyValues) do
          if nv.value == 1 then
              nv.value = 0
              gg.setValues({nv})
              gg.addListItems({nv})
          end
      end
  
      gg.setValues({{address = v.address - 4, flags = gg.TYPE_DWORD, value = 0}})
  end
  
  gg.clearResults()
  gg.clearList()
  gg.alert("ğğ")
end
   if unlockm == 6 then
      valueFromClass("personKit", "0x14", false, false, gg.TYPE_DWORD)
      gg.refineNumber('1000000000~3000000000', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll("0x4", gg.TYPE_DWORD)
      gg.clearResults()
      gg.clearList()

      for _, v in ipairs(results) do
         table.insert(originalValues, v)
         local nearbyValues = gg.getValues({
             {address = v.address - 4, flags = gg.TYPE_DWORD},
         })
     
         for _, nv in ipairs(nearbyValues) do
             if nv.value == 1 then
                 nv.value = 0
                 gg.setValues({nv})
                 gg.addListItems({nv})
             end
         end
     
         gg.setValues({{address = v.address - 4, flags = gg.TYPE_DWORD, value = 0}})
     end
     
     gg.clearResults()
     gg.clearList()
      stopClose()
   end
   if unlockm == 7 then
   gg.clearResults()
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.setVisible(false)
   gg.toast('ğ–ğ€ğˆğ“')
	gg.setVisible(false)
         gg.clearResults()
         gg.clearList()
         gg.setRanges(32)
         d = gg.prompt({
         "ğ„ğğ“ğ„ğ‘ ğ‚ğ€ğ‘ ğğ‘ğˆğ‚ğ„",
         "ğğ€ğ‚ğŠ"
         }, nil, {"number", "checkbox"})
         if not d then
         return
         end
         if d == nil then
         Menu()
         end
         gg.setVisible(false)
         if d[2] then
         return gg.setVisible(true)
         end 
         gg.setRanges(gg.REGION_ANONYMOUS)
         xor = d[1] + "1" .. "x4"
         gg.searchNumber(d[1], gg.TYPE_DWORD)
         gg.refineNumber(xor, 4)
         local results2 = gg.getResults(80)
       for i, v in ipairs(results2) do
     v.address = v.address - 8
     v.value = 0
     gg.setValues({v})
     v.address = v.address - 4 -- C
     gg.setValues({v})
	 gg.toast("ğğ")
   end
end


   if unlockm == 8 then 
      valueFromClass("OneVinylsPreset", "0x18", false, false, gg.TYPE_DWORD)
      gg.refineNumber('1000', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll(0, gg.TYPE_DWORD)
      gg.clearResults()
      gg.clearList()
      gg.alert("ğğ")
      stopClose()
   end
   if unlockm == 9 then
      gg.setVisible(false)
      gg.clearResults()
      gg.setRanges(32)
      gg.searchNumber(-8113896690409954415, gg.TYPE_QWORD)
      HackersHouse = gg.getResults(250000)
      Offsets = {}
      Offsets['FirstOffset'] = {}
      Offsets['SecondOffset'] = {}
      Offsets['FinalResults'] = {}
      OffsetsIndex = 1
      for index, value in ipairs(HackersHouse) do
         Offsets['FirstOffset'][OffsetsIndex] = {}
         Offsets['FirstOffset'][OffsetsIndex].address = HackersHouse[index].address + 4
         Offsets['FirstOffset'][OffsetsIndex].flags = gg.TYPE_QWORD
         Offsets['SecondOffset'][OffsetsIndex] = {}
         Offsets['SecondOffset'][OffsetsIndex].address = HackersHouse[index].address + 8
         Offsets['SecondOffset'][OffsetsIndex].flags = gg.TYPE_QWORD	OffsetsIndex = OffsetsIndex + 1
      end
      Offsets['FirstOffset'] = gg.getValues(Offsets['FirstOffset'])
      Offsets['SecondOffset'] = gg.getValues(Offsets['SecondOffset'])
      OffsetsIndex = 1
      for index, value in ipairs(Offsets['FirstOffset']) do
         if (Offsets['FirstOffset'][index].value == -8183491212919593485) and (Offsets['SecondOffset'][index].value == -8183491208640829927) then
            Offsets['FinalResults'][OffsetsIndex] = {}
            Offsets['FinalResults'][OffsetsIndex] =  Offsets['FirstOffset'][index]
            OffsetsIndex = OffsetsIndex + 1
         end
      end
      for index, value in ipairs(Offsets['FinalResults']) do
         Offsets['FinalResults'][index].address = Offsets['FinalResults'][index].address + 28
         Offsets['FinalResults'][index].flags = 4
      end
      gg.loadResults(Offsets['FinalResults'])
      gg.getResults(9999)
      gg.editAll("0x4", gg.TYPE_DWORD)
      gg.alert("ğƒğğğ„","ğğŠ")
   end
   if unlockm == 10 then
      mainMenu()
   end
   ::unlockmm::
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





function bypass()
   byps = gg.choice({
      "ğ†ğ„ğ“ ğ‹ğ€ğŒğğ",
      "ğ†ğ„ğ“ ğ“ğğ– ğ“ğ‘ğ”ğ‚ğŠ",
      "ğğ˜ğğ€ğ’ğ’ ğ‚ğ”ğ’ğ“ğğŒ ğğ€ğ‘ğ“ğ’",
      "ğğ˜ğğ€ğ’ğ’ ğ“ğ”ğğˆğğ† ğ“ğˆğŒğ„",
      "ğğ˜ğğ€ğ’ğ’ ğ–ğŸğŸ”",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

   if byps == nil then 
      goto bypass
   end
   if byps == 1 then
      valueFromClass("CarDefaultTuningData", "0x1C", false, false, gg.TYPE_DWORD)
      gg.refineNumber(13, gg.TYPE_DWORD)
      gg.getResults(1)
      gg.editAll(18, gg.TYPE_DWORD)
      gg.clearResults()
      gg.toast("ğğ")
      stopClose()
   end
   if byps == 2 then
      valueFromClass("CarDefaultTuningData", "0x1C", false, false, gg.TYPE_DWORD)
      gg.refineNumber(13, gg.TYPE_DWORD)
      gg.getResults(1)
      gg.editAll(101, gg.TYPE_DWORD)
      gg.clearResults()
      gg.toast("ğğ")
      stopClose()
   end
   if byps == 3 then
	  valueFromClass("CarEntityMonoBehaviour", "0x161", false, false, gg.TYPE_BYTE)
	  gg.refineNumber('0~1', gg.TYPE_BYTE)
	  local revert = gg.getResults(50)
	  gg.editAll(0, gg.TYPE_BYTE)
	  gg.toast("ğ†ğ ğ“ğ ğğğ‹ğˆğğ„ ğ‘ğğğŒ ğ…ğ€ğ’ğ“ ğ˜ğğ” ğ‡ğ€ğ•ğ„ ğŸ• ğ’ğ„ğ‚ğğğƒğ’")
	  gg.setVisible(false)
	  gg.sleep(7000)
	  gg.setValues(revert)
      gg.toast("ğğ")
      stopClose()
   end
   if byps == 4 then
      valueFromClass("TuningTimesToWaitConfig", "0x18", false, false, gg.TYPE_FLOAT)
      gg.getResults(999)
      gg.editAll(0, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğ–ğ€ğˆğ“")
      valueFromClass("TuningTimesToWaitConfig", "0x1C", false, false, gg.TYPE_FLOAT)
      gg.getResults(999)
      gg.editAll(0, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.toast("ğğ")
      stopClose()
   end
   if byps == 5 then 
      valueFromClass("CarEntityMonoBehaviour", "0x160", false, false, gg.TYPE_BYTE)
      gg.refineNumber('0~1', gg.TYPE_BYTE)
      gg.getResults(50)
      gg.editAll(0, gg.TYPE_BYTE)
      gg.clearResults()
      gg.toast("ğğ")
      stopClose()
   end
   if byps == 6 then 
      mainMenu()
   end
   ::bypass::
end









----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



function shifttime()
   shift = gg.choice({
      "ğ’ğ‡ğˆğ…ğ“ ğ“ğˆğŒğ„ (ğŸ.ğŸğŸğŸğŸ)",
      "ğ’ğ‡ğˆğ…ğ“ ğ“ğˆğŒğ„ (ğŸğ„-ğŸ‘ğŸ) ğ/ğ€",
      "ğ’ğ‡ğˆğ…ğ“ ğ“ğˆğŒğ„ (ğŸğ„-ğŸğŸ—) ğ/ğ€",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

   if shift == nil then
      goto shiftt
   end
   if shift == 1 then
      valueFromClass("MainCarValues", "0x58", false, false, gg.TYPE_DWORD)
      gg.refineNumber('1000', gg.TYPE_DWORD)
      gg.getResults(999)
      gg.editAll(0, gg.TYPE_DWORD)

      local allResults = gg.getResults(gg.getResultsCount())
      local resultsToEdit = {}
      for i = 1, math.min(numberOfResults, #allResults) do
      table.insert(resultsToEdit, allResults[i])
      end

      for i = 1, #resultsToEdit do
      resultsToEdit[i].value = 1.0E-4
      end

      gg.setValues(resultsToEdit)

      gg.clearResults()
      gg.clearList()
      gg.alert("ğğ")
      stopClose()
   end
   if shift == 2 then
      gg.alert("ğğğ“ ğ€ğ•ğ€ğˆğ‹ğ€ğğ‹ğ„")
   end
   if shift == 3 then
      gg.alert("ğğğ“ ğ€ğ•ğ€ğˆğ‹ğ€ğğ‹ğ„")
   end
   if shift == 4 then
      mainMenu()
   end
   ::shiftt:: 
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



gg.setVisible(false)
function dynotune()
   gg.setVisible(false)
   local bm = gg.prompt({"ğ€ğ…ğ‘ ğ‚ğğğ“ğ‘ğğ‹ğ‹ğ„ğ‘ [ğŸğŸğŸ~ğŸğŸ–ğŸ]","ğğğğ’ğ“ ğ‚ğğğ“ğ‘ğğ‹ğ‹ğ„ğ‘ [ğŸ.ğŸğŸ‘]"}, nil, {"number","number"})
   if bm == nil then
     gg.toast("ğ‚ğ€ğğ‚ğ„ğ‹ğ„ğƒ")
     return
   end
   
   valueFromClass("DynamicTuningValues", "0x58", false, false, gg.TYPE_FLOAT)
   gg.refineNumber('12.14999961853~14.85000038147', gg.TYPE_FLOAT)
   local results = gg.getResults(500)
   gg.editAll(bm[1], gg.TYPE_FLOAT)
   
   local originalValues = {}
   
   for _, v in ipairs(results) do
       table.insert(originalValues, v)
       
      
       local nearbyAddress = v.address - 0x3C
       local nearbyValues = gg.getValues({
           {address = nearbyAddress, flags = gg.TYPE_FLOAT},
       })
   
       for _, nv in ipairs(nearbyValues) do
           if nv.value == 1 then
               nv.value = bm[2]
               gg.setValues({nv})
               gg.addListItems({nv})
           end
       end
   
       gg.setValues({{address = nearbyAddress, flags = gg.TYPE_FLOAT, value = bm[2]}})
   end
   gg.clearResults()
   gg.clearList()
   gg.alert("ğğ")
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

originalValues = {}

gg.setVisible(false)
function tuning()
   gg.setVisible(false)
   gg.clearResults()
   gg.clearList()
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.searchNumber('600', gg.TYPE_FLOAT)
   local results = gg.getResults(200)
   gg.editAll('0', gg.TYPE_FLOAT)  

   for _, v in ipairs(results) do
       table.insert(originalValues, v)  
       local nearbyValues = gg.getValues({
           {address = v.address - 4, flags = gg.TYPE_FLOAT},  -- Offset para 0x4
       })

       for _, nv in ipairs(nearbyValues) do
           if nv.value == 1 then
               nv.value = 0
               gg.setValues({nv})
               gg.addListItems({nv})  
           end
       end

       
       gg.setValues({{address = v.address - 4, flags = gg.TYPE_FLOAT, value = 0}})
   end

   gg.clearResults()
   gg.clearList()
   gg.alert("ğğ")
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

gg.setVisible(false)
function EditMass()
   gg.setVisible(false)
local bm = gg.prompt({"ğ„ğğ¢ğ­ ğŒğšğ¬ğ¬ ğ‚ğšğ« [ğ‘ğğœğ¨ğ¦ğğ§ğ:ğŸğŸğŸğŸ]"}, nil, {"number"})
if bm == nil then
  gg.toast("ğ‚ğ€ğğ‚ğ„ğ‹ğ‹ğ„ğƒ")
  return
end
      gg.setVisible(false)
    gg.clearResults()
    gg.setRanges(gg.REGION_ANONYMOUS)
    gg.searchNumber('5', gg.TYPE_DWORD)
    gg.clearResults()
    gg.clearList()
valueFromClass("CarDefaultTuningDataConfig", "0x1C", false, false, gg.TYPE_DWORD)
gg.refineNumber('1000~3000', gg.TYPE_FLOAT)
local results = gg.getResults(999)
gg.editAll(bm[1], gg.TYPE_FLOAT)
gg.clearResults()
gg.clearList()
gg.alert("ğğ")
end


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



on = '     âƒ¢ ğŸŸ¢' 
off ='ğŸ”´ âƒ¢     '

prank2 = off
prank3 = off
prank4 = off
prank5 = off
prank6 = off
prank7 = off
prank8 = off

 
gg.setVisible(false)
function prank()
gg.setVisible(false)
prm = gg.choice({
    "ğğğ„ğ ğ•ğ„ğ‡ğˆğ‚ğ‹ğ„",  ---1
prank2 .. "ğ’ğğ„ğ„ğƒ ğ–ğ€ğ‹ğŠ ğ‹ğğ–", ---2
prank3 .. "ğ’ğğ„ğ„ğƒ ğ–ğ€ğ‹ğŠ ğŒğ„ğƒğˆğ”ğŒ", ---3
prank4 .. "ğ’ğğ„ğ„ğƒ ğ–ğ€ğ‹ğŠ ğ‡ğˆğ†ğ‡", ---4
prank5 .. "ğ‚ğ€ğ‘ ğƒğ€ğğ‚ğ„ ", ---5
prank6 .. "CAR ROLLER",  ---6
prank7 .. "TELEPORT", ----7
prank8 .. "ğ€ğ”ğ“ğ ğ‹ğğ€ğƒ / ğ–ğ€ğ‹ğ‹ ğ‡ğ€ğ‚ğŠ", ---8
'ğğ€ğ‚ğŠ'},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))
 
if prm == nil then
    goto prk
end
 
 
if prm == 1 then
    prk1()
end
 
 
if prm == 2 then
if prank2 == on then 
	prank2 = off 
	else
	prank2 = on 
	end
	prk2()
end
 
 
 
if prm == 3 then
if prank3 == on then 
	prank3 = off 
	else
	prank3 = on 
	end
	prk3()
end
 
 
 
 
 
if prm == 4 then
if prank4 == on then 
	prank4 = off 
	else
	prank4 = on 
	end
	prk4()
end
 
 
 
 
 
 
if prm == 5 then
if prank5 == on then 
	prank5 = off 
	else
	prank5 = on 
	end
	prk5()
end
 
 
 
 
if prm == 6 then
if prank6 == on then 
	prank6 = off 
	else
	prank6 = on 
	end
	prk6()
end
 



if prm == 7 then
if prank7 == on then 
   prank7 = off 
   else
   prank7 = on 
   end
   prk7()
end




if prm == 8 then
if prank8 == on then 
   Prank8 = off 
   else
   prank8 = on 
   end
   prk8()
end
 
 if prm == 9 then
	mainMenu()
end
::prk::
end

 

 
 
 

 
function prk1()
   ACKA01=gg.getRangesList('libil2cpp.so')[2].start
   APEX=nil  APEX={}
   APEX[1]={}
   APEX[1].address=ACKA01+0x3225938+0
   APEX[1].value='D2800020h'
   APEX[1].flags=4
   APEX[2]={}
   APEX[2].address=ACKA01+0x3225938+4
   APEX[2].value='D65F03C0h'
   APEX[2].flags=4
   gg.setValues(APEX)
    gg.toast("ğ€ğ‚ğ“ğˆğ•ğ„")
end
 
 
 

 
 
function prk2()
gg.setVisible(false)
if prank2 == on then 
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_ANONYMOUS)
	gg.searchNumber("1", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("10", gg.TYPE_DOUBLE)
	gg.toast("ğ‹ğğ– ğ‘ğ”ğ ğğ ") 
else
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_ANONYMOUS)
	gg.searchNumber("10", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("1", gg.TYPE_DOUBLE)
	gg.clearResults()
	gg.toast("ğ‘ğ”ğ ğğ…ğ…") 
end
end 
 
 
function prk3()
gg.setVisible(false)
if prank3 == on then 
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_ANONYMOUS)
	gg.searchNumber("1", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("16", gg.TYPE_DOUBLE)
	gg.toast("ğŒğ„ğƒğˆğ”ğŒ ğ‘ğ”ğ ğğ ")
else
	gg.clearResults()
	gg.clearList()
	gg.searchNumber("16", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("1", gg.TYPE_DOUBLE)
	gg.clearResults()
	gg.toast("ğ‘ğ”ğ ğğ…ğ…") 
end
end
 
 
function prk4()
gg.setVisible(false)
if prank4 == on then 
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_ANONYMOUS)
	gg.searchNumber("1", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("25", gg.TYPE_DOUBLE)
	gg.toast("ğ‡ğˆğ†ğ‡ ğ‘ğ”ğ ğğ")
else
	gg.clearResults()
	gg.clearList()
	gg.searchNumber("25", gg.TYPE_DOUBLE, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("1", gg.TYPE_DOUBLE)
	gg.clearResults()
	gg.toast("ğ‘ğ”ğ ğğ…ğ…")
end
end
 

 
function prk5()
gg.setVisible(false)
if prank5 == on then 
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_C_DATA)
	gg.searchNumber("10000000", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("-999", gg.TYPE_FLOAT)
	gg.clearResults()
	gg.toast("ğƒğ€ğğ‚ğˆğğ† ğ‚ğ€ğ‘ ğğ") 
else
	gg.clearResults()
	gg.clearList()
	gg.setRanges(gg.REGION_C_DATA)
	gg.searchNumber("-999", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
	revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
	gg.editAll("10000000", gg.TYPE_FLOAT)
	gg.clearResults()
	gg.clearResults()
	gg.toast("ğƒğ€ğğ‚ğˆğğ† ğ‚ğ€ğ‘ ğğ…ğ…") 
end
end
 
function prk6()
gg.setVisible(false)
if prank6 == on then 
   gg.setVisible(false)
   gg.clearResults()
   gg.clearList()
   gg.setRanges(gg.REGION_CODE_APP)
   gg.searchNumber("100", gg.TYPE_FLOAT)
   gg.setVisible(false)
   gg.getResults(48)
   gg.editAll("1000", gg.TYPE_FLOAT)
   gg.clearResults()
   gg.clearList()
	gg.toast('ğ€ğ‚ğ“ğˆğ•ğ„!') 
else
   gg.setVisible(false)
   gg.clearResults()
   gg.clearList()
   gg.setRanges(gg.REGION_CODE_APP)
   gg.searchNumber("1000", gg.TYPE_FLOAT)
   gg.setVisible(false)
   gg.getResults(48)
   gg.editAll("100", gg.TYPE_FLOAT)
   gg.clearResults()
   gg.clearList()
	gg.toast('ğƒğˆğ€ğ‚ğ“ğˆğ•ğ€ğ“ğ„ğƒ') 
end
end

function prk7()
gg.setVisible(false)
if prank6 == on then 
   gg.clearResults()
   gg.clearList()
   gg.setRanges(gg.REGION_CODE_APP)
   gg.searchNumber("2000", 16)
   revert = gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil)
   for i, i in ipairs((gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil))) do
     if i.flags == 16 then
       i.value = "-9999"
       i.freeze = true
     end 
   end
   gg.addListItems((gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil)))
   gg.clearResults()
   gg.clearList()
   gg.toast('ğ€ğ‚ğ“ğˆğ•ğ„!') 
else
   gg.setRanges(gg.REGION_CODE_APP)
   gg.searchNumber("-9999", 16)
   revert = gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil)
   for i, i in ipairs((gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil))) do
     if i.flags == 16 then
       i.value = "2000"
       i.freeze = true
     end 
   end
   gg.addListItems((gg.getResults(8769, nil, nil, nil, nil, nil, nil, nil, nil)))
   gg.clearResults()
   gg.clearList()
   gg.toast('ğƒğˆğ€ğ‚ğ“ğˆğ•ğ€ğ“ğ„ğƒ') 
end
end

function prk8()
gg.setVisible(false)
if prank6 == on then 
   gg.clearResults()
   gg.clearList()
   -- main code on
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.searchNumber("2.4611913e-38;-10.0;3.40282347e38:65", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
   revert = gg.getResults(1000, nil, nil, nil, nil, nil, nil, nil, nil)
   gg.refineNumber("-10.0", gg.TYPE_FLOAT)
   gg.getResults(999)
   gg.editAll("999.9", gg.TYPE_FLOAT)
   gg.clearResults()
   gg.toast('ğ€ğ‚ğ“ğˆğ•ğ„!') 
else
   gg.clearResults()
   gg.clearList()
   -- main code on
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.searchNumber("999.9", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
   gg.getResults(999)
   gg.editAll("-10.0", gg.TYPE_FLOAT)
   gg.clearResults()
   gg.toast('ğƒğˆğ€ğ‚ğ“ğˆğ•ğ€ğ“ğ„ğƒ') 
end
end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   

gg.setVisible(false)
function achivement()
   gg.setVisible(false)
   firstMenu = gg.choice({ 
       "ğğ‹ğğ‚ğŠ ğğğ’ğ“",
       "ğ’ğğ„ğ„ğƒ ğğ€ğğğ„ğ‘",
       "ğƒğ‘ğ€ğ† ğ–ğˆğğ’",
       "ğğğ‹ğˆğ‚ğ„",
       "ğ“ğˆğ‘ğ„ ğğ”ğ‘ğğ“",
       "ğ…ğ”ğ„ğ‹ ğ‚ğğğ’ğ”ğŒğ„ğƒ",
       "ğ‚ğ€ğ‘ ğ–ğ€ğ’ğ‡",
       "ğ‚ğ€ğ‘ ğ‘ğ„ğğ€ğˆğ‘",
       "ğ„ğŒğğ“ğˆğğğ’",
       "ğƒğˆğ’ğ“ğ€ğğ‚ğ„",
       "ğŒğˆğ‹ğ„ğ€ğ†ğ„ ğğ€ğ’ğ’ğ„ğğ†ğ„ğ‘",
       "ğ†ğ€ğŒğ„ ğ“ğˆğŒğ„",
       "OFFROAD",
       "ROAD KING",
       "DRIFT",
   "âŒğğ€ğ‚ğŠâŒ"  }, nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))
      if firstMenu == nil then
         goto nill
      end
      if firstMenu == 1 then
         cheat_1()
      end
      if firstMenu ==2  then
         cheat_2()
      end
      if firstMenu == 3 then
         cheat_3()
      end
      if firstMenu == 4 then
         cheat_4()
      end
      if firstMenu == 5 then
         cheat_5()
      end
      if firstMenu == 6 then
         cheat_6()
      end
      if firstMenu == 7 then
         cheat_7()
      end
      if firstMenu == 8 then
         cheat_8()
      end
      if firstMenu == 9 then
         cheat_9()
      end
      if firstMenu == 10 then
         cheat_10()
      end
      if firstMenu == 11 then
         cheat_11()
      end
      if firstMenu == 12 then
         cheat_12()
      end
      if firstMenu == 13 then
         cheat_13()
      end
      if firstMenu == 14 then
         cheat_14()
      end
      if firstMenu == 15 then
         cheat_15()
      end
      if firstMenu == 16 then
         mainMenu()
      end
      ::nill::
   end
   
   function cheat_1()
      valueFromClass("DataBaseFreeDrive", "0x84", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_2()
      valueFromClass("DataBaseFreeDrive", "0x98", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_3()
      valueFromClass("DataBaseFreeDrive", "0xAC", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_4()
      valueFromClass("DataBaseFreeDrive", "0xC0", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_5()
      valueFromClass("DataBaseFreeDrive", "0xD4", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_6()
      valueFromClass("DataBaseFreeDrive", "0xE8", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_7()
      valueFromClass("DataBaseFreeDrive", "0xFC", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_8()
      valueFromClass("DataBaseFreeDrive", "0x110", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_9()
      valueFromClass("DataBaseFreeDrive", "0x124", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_10()
      valueFromClass("NewMove", "0xB8", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_11()
      valueFromClass("NewMove", "0xD0", false, false, gg.TYPE_FLOAT)
      gg.getResults(9999)
      gg.editAll(999, gg.TYPE_FLOAT)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end
   
   function cheat_12()
      valueFromClass("AnaliticsWhere", "0x24", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end

   function cheat_13()
      valueFromClass("Drivetrain", "0x248", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end

   function cheat_14()
      valueFromClass("Drivetrain", "0x218", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end

   function cheat_15()
      valueFromClass("Drivetrain", "0x230", false, false, gg.TYPE_DWORD)
      gg.getResults(9999)
      gg.editAll(99999, gg.TYPE_DWORD)
      gg.clearResults()
      gg.alert("ğğ")
      stopClose()
   end



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


   gg.setVisible(false)
function others()
   gg.setVisible(false)
   oth = gg.choice({
      "ğğ”ğ˜ ğ‚ğ€ğ‘ ğ…ğğ‘ $ğŸ",
      "ğğˆğ† ğ“ğˆğ‘ğ„ğ’",
      "ğğˆğ† ğğ‘ğ€ğŠğ„ğ’",
      "ğ‡ğˆğ†ğ‡ ğ‚ğ€ğ‘",
      "ğğ ğğ”ğŒğğ„ğ‘",
   "ğğ€ğ‚ğŠ"},nil,"ğŸ”’ğ„ğğ‚ğ‘ğ˜ğğ“ğ„ğƒ ğğ˜ ğğğ‹ğ˜ ğ“ğ‘ğˆğ’ ğ•ğŸğŸ“ğŸ”’"..os.date('\n\nâ˜€ï¸ğ“ğğƒğ€ğ˜ : %h %d %Y\nâŒšğ“ğˆğŒğ„ : %H:%M\n'))

   if oth == nil then
      goto othh
   end
   if oth == 1 then 
         gg.setVisible(false)
         gg.clearResults()
         gg.clearList()
         gg.setRanges(32)
         d = gg.prompt({
         "ğ„ğğ“ğ„ğ‘ ğ‚ğ€ğ‘ ğğ‘ğˆğ‚ğ„",
         "ğğ€ğ‚ğŠ"
         }, nil, {"number", "checkbox"})
         if not d then
         return
         end
         if d == nil then
         Menu()
         end
         gg.clearResults()
         gg.setVisible(false)
         if d[2] then
         return gg.setVisible(true)
         end 
         gg.setRanges(gg.REGION_ANONYMOUS)
         xor = d[1] .. "x4"
         gg.searchNumber(xor, 4)
         gg.getResults(100)
         gg.editAll("0x4", 4)
         gg.alert("ğğ")
         gg.clearResults()
         gg.clearList()
      end
      if oth == 2 then
         gg.setRanges(gg.REGION_ANONYMOUS)
         gg.alert("ğ†ğ ğ“ğ ğ•ğˆğ’ğ”ğ€ğ‹ ğ“ğ”ğğˆğğ† ğ“ğ‡ğ„ğ ğ‘ğˆğŒğ’")
         gg.sleep(5000)
         gg.toast("ğ…ğˆğğƒ ğŸ’ğŸ’ğŸ“ ğˆğ ğ‘ğˆğŒğ’")
         gg.sleep(3000)
         gg.searchNumber("445", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.toast("ğ’ğ‹ğˆğƒğ„ ğ“ğ ğŸ’ğŸ“ğŸ“")
         gg.sleep(3000)
         gg.searchNumber("455", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.editAll("1500",gg.TYPE_DWORD)
         gg.toast("âœ…ğ‚ğğŒğğ‹ğ„ğ“ğ„ğƒâœ…")  
      end
      if oth == 3 then 
         gg.setVisible(false)
         gg.setRanges(gg.REGION_ANONYMOUS)
         gg.alert("ğ†ğ ğ“ğ ğ•ğˆğ’ğ”ğ€ğ‹ ğ“ğ”ğğˆğğ† ğ“ğ‡ğ„ğ ğğ‘ğ€ğŠğ„ğ’")
         gg.sleep(5000)
         gg.toast("ğ’ğ‹ğˆğƒğ„ ğ“ğ‡ğ„ ğ’ğ‹ğˆğƒğ„ğ‘ ğğ€ğ‘ ğ“ğ ğŸğŸ—ğŸ")
         gg.sleep(3000)
         gg.searchNumber("190", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.toast("ğ’ğ‹ğˆğƒğ„ ğ“ğ‡ğ„ ğ’ğ‹ğˆğƒğ„ğ‘ ğğ€ğ‘ ğ“ğ ğŸ’??ğŸ–")
         gg.sleep(3000)
         gg.searchNumber("458", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.editAll("1000",gg.TYPE_FLOAT)
         gg.toast("âœ…ğ‚ğğŒğğ‹ğ„ğ“ğ„ğƒâœ…")
      end
      if oth == 4 then 
         gg.setVisible(false)
         gg.setRanges(gg.REGION_ANONYMOUS)
         gg.alert("ğ†ğ ğ“ğ ğ’ğ”ğ’ğğ„ğğ“ğˆğğ ğ€ğğƒ ğ“ğ‡ğ„ğ ğ…ğˆğğƒ ğ‘ğˆğƒğ„ ğ‡ğˆğ†ğ‡ğ“")
         gg.sleep(5000)
         gg.toast("ğ’ğ‹ğˆğƒğ„ ğˆğ“ ğ“ğ ğŒğˆğğˆğŒğ”ğŒ")
         gg.sleep(3000)
         gg.searchNumber("1", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.toast("ğ’ğ‹ğˆğƒğ„ ğˆğ“ ğ“ğ ğŒğ€ğ—ğˆğŒğ”ğŒ")
         gg.sleep(3000)
         gg.searchNumber("16", gg.TYPE_FLOAT, false, gg.SIGN_EQUAL, 0, -1, 0)
         gg.editAll("5",gg.TYPE_FLOAT)
         gg.toast("âœ…ğ‚ğğŒğğ‹ğ„ğ“ğ„ğƒâœ…")
      end
      if oth == 5 then
		  gg.setVisible(false)
          choice = gg.alert("ğğğ“ğ„ ğ˜ğğ” ğğ„ğ„ğƒ ğ“ğ ğğ”ğ‘ğ‚ğ‡ğ€ğ‚ğ„ ğ“ğ‡ğ„ ğŸ“ğ“ğ‡ ğ‘ğ„ğ€ğ‘ ğğ”ğŒğğ„ğ‘. ğƒğ ğ˜ğğ” ğ–ğˆğ’ğ‡ ğ“ğ ğ‚ğğğ“ğˆğğ”ğ„? ğğ‘ğ„ğ’ğ’ [ğ˜ğ„ğ’] ğ“ğ ğ‚ğğğ“ğˆğğ”ğ„ ğ€ğğƒ [ğğ] ğ“ğ ğ†ğ ğğ€ğ‚ğŠ ğ“ğ ğŒğ„ğğ”","ğ˜ğ„ğ’",nil,"ğğ")

              if choice == 1 then
                  gg.toast("ğğ‹ğ„ğ€ğ’ğ„ ğ–ğ€ğˆğ“")
              elseif choice == 3 then
                gg.toast("ğ†ğğˆğğ† ğğ€ğ‚ğŠ ğ“ğ ğŒğ„ğğ”")
                  unlockmenu()
              else
                  gg.toast("ğˆğğ•ğ€ğ‹ğˆğƒ ")
                  unlockmenu()
              end
          gg.alert ("ğ¢ğ§ğ¬ğ­ğšğ¥ğ¥ ğ‘ğğšğ« ğŸ“ ğ­ğ¡ğğ§ ğœğ¥ğ¢ğœğ¤ ğ†ğ† ğ¥ğ¨ğ ğ¨ ğ­ğ¨ ğ¬ğ­ğšğ«ğ­")
          gg.clearResults()
          gg.clearList()
          while true do
          if gg.isVisible() then
          break
          else
          gg.sleep(50)
          end end 
          gg.setVisible(false) 
          gg.clearResults()
          valueFromClass("InstalledBodyKits", "0x18", false, false, gg.TYPE_DWORD)
          gg.refineNumber("4", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
          gg.getResults(50)
          gg.editAll("5",gg.TYPE_DWORD)
          gg.clearResults()
          gg.clearList()
          gg.alert ("ğ†ğ ğ“ğ ğ‹ğ„ğ•ğ„ğ‹ ğŸ ğ“ğ‡ğ„ğ ğğ€ğ‚ğŠ ğ“ğ ğŒğ„ğğ”")
         gg.toast("âœ…ğ‚ğğŒğğ‹ğ„ğ“ğ„ğƒâœ…")
      end
      if oth == 6 then 
         mainMenu()
      end
      ::othh:: 
   end

      
   


























































Results = {}
function valueFromClass(class, offset, tryHard, bit32, valueType, SearchMode)
   if not SearchMode then
      SearchMode = { [1] = 'Class', [2] = 0x0 }
   end

   if SearchMode[1] == "Class" then
      SearchTypeSelection = 1
      Get_second_feild_offset = {}
      Get_second_feild_offset[1] = "0x0"
   elseif SearchMode[1] == "Struct" then
      SearchTypeSelection = 2
      Get_second_feild_offset = {}
      Get_second_feild_offset[1] = SearchMode[2]
   elseif SearchMode[1] == "ChildClass" then
      SearchTypeSelection = 3
      Get_second_feild_offset = {}
      Get_second_feild_offset[1] = SearchMode[2]
   end



   Get_user_input = {}
   Get_user_input[1] = class
   Get_user_input[2] = offset
   Get_user_input[3] = tryHard
   Get_user_input[4] = bit32


   if (valueType == gg.TYPE_BYTE or valueType == gg.TYPE_DWORD or valueType == gg.TYPE_QWORD or valueType == gg.TYPE_FLOAT or valueType == gg.TYPE_DOUBLE) then
      Get_user_type = valueType
   elseif (valueType == "Vector2") then
      Get_user_type = 6
   elseif (valueType == "Vector2Int") then
      Get_user_type = 7
   elseif (valueType == "Vector3") then
      Get_user_type = 8
   elseif (valueType == "Vector3Int") then
      Get_user_type = 9
   elseif (valueType == "Vector4") then
      Get_user_type = 10
   elseif (valueType == "Vector4Int") then
      Get_user_type = 11
   elseif (valueType == "String") then
      Get_user_type = 12
   elseif (valueType == "Bounds") then
      Get_user_type = 13
   elseif (valueType == "BoundsInt") then
      Get_user_type = 14
   elseif (valueType == "Matrix2x3") then
      Get_user_type = 15
   elseif (valueType == "Matrix4x4") then
      Get_user_type = 16
   elseif (valueType == "Color") then
      Get_user_type = 17
   elseif (valueType == "Color32") then
      Get_user_type = 18
   elseif (valueType == "Quaternion") then
      Get_user_type = 19
   end
   start()
   if error ~= 'fail' then
      local LatestValuesOfResult = gg.getValues(Results)
      for index, value in ipairs(Results) do
         Results[index].value = LatestValuesOfResult[index].value
      end

      return Results
   else
      return {}
   end
end

function loopCheck()
   if userMode == 1 then
      UI()
   elseif error == 3 then
      stopClose()
   end
end


function found_(message)
   if error == 1 then
      found2(message)
   elseif error == 2 then
      found3(message)
   elseif error == 3 then
      found4(message)
   else
      found(message)
   end
end

function found(message)
   if count == 0 then
      gg.clearResults()
      first_error = message
      error = 1
      second_start()
   end
end

function found2(message)
   if count == 0 then
      gg.clearResults()
      second_error = message
      error = 2
      third_start()
   end
end

function found3(message)
   if count == 0 then
      gg.clearResults()
      third_error = message
      error = 3
      fourth_start()
   end
end

function found4(message)
   if count == 0 then
      error = 'fail'
      gg.clearResults()
      gg.alert("âŒValue NOT FOUNDâŒ\nError Log:\nTry 1: " ..
         first_error ..
         "\nTry 2: " ..
         second_error ..
         "\nTry 3: " ..
         third_error ..
         "\nTry 4: " ..
         message ..
         "\n\nâ„¹ï¸Try Thisâ„¹ï¸\n\nğŸŸ¢1: Make Sure You are Using Correct Version Of game and the dump. 64 bit game and 64 bit dump or 32 bit game 32 bit dump + check try for 32 bit option in script or Version of game and same version of dump.\n\nğŸŸ¡2: Is the value allocated? if you are searching for player health maybe that value only loads after you load match and took some damage. So try again while playing\n\nğŸ”´3: Is the class name correct? for example if the class is playerscript then don't forget to make P and S capital. So type PlayerScript not playerscript\n\nâš«4: Is the offset right? you have to type 0x before the offset for example the offset is C1 then you have to Give 0xC1 to this script\n\nğŸŸ¤5: Tried Everything but still didn't work? then contact the devloper of this script ")
      gg.setVisible(true)
      loopCheck()
   end
end

function SearchTypeChooser()
   local MenuItems
   MenuItems = {}
   for index, value in ipairs(SearchType) do
      MenuItems[index] = value['topic']
   end

   :: repeatMenu ::
   Menu = gg.choice(MenuItems, 0, "Please select The Search Type")
   if Menu == nil then
      gg.alert("â„¹ï¸ Error : Please Select An Option â„¹ï¸")
      goto repeatMenu
   end

   SearchTypeSelection = Menu
end


function user_input_taker()
   SearchType = {
      [1] = {
         ['topic'] = 'Class Search',
         ['name'] = 'Class Name',
         ['offset'] = 'Feild Offset',
      },
      [2] = {
         ['topic'] = 'Struct Search',
         ['name'] = 'Struct Container Class Name',
         ['offset'] = 'Struct Offset inside Container Class',
         ['offsetSecond'] = 'Input Struct Feild Offset : ',
      },
      [3] = {
         ['topic'] = 'Child Class Search',
         ['name'] = 'Container Class Name',
         ['offset'] = 'Child Class Offset inside Container Class',
         ['offsetSecond'] = 'Input Child Class Feild Offset : ',
      }
   }

   ::stort::
   gg.clearResults()
   if userMode == 1 then
      if Get_user_input == nil then
         default1 = "GameController"
         default2 = "0x50"
         default3 = false
         if (gg.getTargetInfo().x64) then
            default4 = false
         else
            default4 = true
         end
         SearchTypeSelection = 1
         default5 = false
         default7 = false
      else
         default1 = Get_user_input[1]
         default2 = Get_user_input[2]
         default3 = Get_user_input[3]
         default4 = Get_user_input[4]
         default5 = Get_user_input[6]
         default7 = Get_user_input[7]
      end
      if SearchTypeSelection == 1 then
         Get_user_input = gg.prompt(
            { "ğŸ”°Script ByğŸ”°: SLOW CPM\n\nScript Mode : " ..
            SearchType[SearchTypeSelection]['topic'] .. "\n\n " .. SearchType[SearchTypeSelection]['name'] .. " : ",
               SearchType[SearchTypeSelection]['offset'] .. " : ", "Try Harder --(decreases accuracy)", "Try For 32 bit",
               'Change Search Mode', 'Give names and save', 'Custom Load (Load multiple With names)' },
            { default1, default2, default3, default4, false, default5, default7 },
            { "text", "text", "checkbox", "checkbox", "checkbox", "checkbox", "checkbox" })
      else
         Get_user_input = gg.prompt(
            { "ğŸ”°Script ByğŸ”°: SLOW CPM\n\nScript Mode : " ..
            SearchType[SearchTypeSelection]['topic'] .. "\n\n " .. SearchType[SearchTypeSelection]['name'] .. " : ",
               SearchType[SearchTypeSelection]['offset'] .. " : ", "Try Harder --(decreases accuracy)", "Try For 32 bit",
               'Change Search Mode', 'Give names and save', },
            { default1, default2, default3, default4, false, default5 },
            { "text", "text", "checkbox", "checkbox", "checkbox", "checkbox" })
         Get_user_input[7] = false
      end

      if Get_user_input ~= nil then
         if Get_user_input[7] then
            Get_user_input[2] = 0x0
            ::CustomInput::
            CustomLoadData = gg.prompt({
               'Input The code from DUMP.CS file\nCopy from the class/struct name files and feilds\nproperties and methods not required ' })

            if CustomLoadData == nil then
               gg.alert("â„¹ï¸Please dont leave the input emptyâ„¹ï¸")
               goto CustomInput
            end
         end


         if Get_user_input[5] == true then
            SearchTypeChooser()
            goto stort
         end
         if (Get_user_input[1] == "") or (Get_user_input[2] == "") then
            gg.alert("â„¹ï¸ Don't Leave Input Blankâ„¹ï¸")
            goto stort
         end
      else
         gg.alert("â„¹ï¸ Error : Try again â„¹ï¸")
         goto stort
      end





      ::UserTypeChooser::
      if Get_user_input[7] then
         Get_user_type = 20
      else
         Get_user_type = gg.choice(
            { "1. Byte / Boolean", "2. Dword / 32 bit Int", "3. Qword / 64 bit Int", "4. Float", "5. Double",
               "6. Vector2",
               "7. Vector2Int", "8. Vector3", "9. Vector3Int", "10. Vector4", "11. Vector4Int", "12. String",
               "13. Bounds",
               "14. BoundsInt", "15. Matrix2x3", "16. Matrix4x4", "17. Color", "18. Color32", "19. Quaternion",
               "+ Add Custom + " }, nil,
            "ğŸ”°Script ByğŸ”°: https://t.me/Hackers_House_YT\n\nâ„¹ï¸ Choose The Output Type â„¹ï¸")
      end


      if (Get_user_type == nil) then
         gg.alert("â„¹ï¸ Please select a type â„¹ï¸")
         goto UserTypeChooser
      end
      if Get_user_type == 1 then
         Get_user_type = gg.TYPE_BYTE
      elseif Get_user_type == 2 then
         Get_user_type = gg.TYPE_DWORD
      elseif Get_user_type == 3 then
         Get_user_type = gg.TYPE_QWORD
      elseif Get_user_type == 4 then
         Get_user_type = gg.TYPE_FLOAT
      elseif Get_user_type == 5 then
         Get_user_type = gg.TYPE_DOUBLE
      end
      if Get_user_type ~= gg.TYPE_BYTE then
         local hex_values = {}
         if Get_user_input[7] then
            Get_user_input[2] = tostring(Get_user_input[2])
         end
         for hex in Get_user_input[2]:gmatch("0x%x+") do
            table.insert(hex_values, hex)
         end

         if Get_user_input[7] then
            Get_user_input[2] = string.format("0x%X", tonumber(Get_user_input[2]))
         end


         -- Verify the offsets
         for i, v in ipairs(hex_values) do
            if (v % 4) ~= 0 then
               gg.alert("â„¹ï¸Hex Offset Must Be An Multiple OF 4â„¹ï¸")
               goto stort
            end
         end
      end

      if Get_user_type ~= 20 or SearchTypeSelection == 3 then
         :: SearchType ::
         if (SearchTypeSelection == 2 or SearchTypeSelection == 3) then
            if Get_second_feild_offset == nil then
               defaultSecondOffset = "0xBC"
            else
               defaultSecondOffset = Get_second_feild_offset[1]
            end
            Get_second_feild_offset = gg.prompt(
               { "ğŸ”°Script ByğŸ”°: https://t.me/Hackers_House_YT\n\n" .. SearchType[SearchTypeSelection]['offsetSecond'] },
               { defaultSecondOffset })

            if Get_second_feild_offset == nil or Get_second_feild_offset[1] == "" then
               gg.alert("â„¹ï¸ Error : Dont leave the input empty â„¹ï¸")
               goto SearchType
            end
         end


         if (SearchTypeSelection == 2 or SearchTypeSelection == 3) then
            local hexx_values = {}
            for hex in Get_second_feild_offset[1]:gmatch("0x%x+") do
               table.insert(hexx_values, hex)
            end

            -- Verify the offsets
            for i, v in ipairs(hexx_values) do
               if (v % 4) ~= 0 then
                  gg.alert("â„¹ï¸Hex Offset Must Be An Multiple OF 4â„¹ï¸")
                  goto SearchType
               end
            end
         end
      else
         Get_second_feild_offset = {}
         Get_second_feild_offset[1] = "0x0"
      end

      if Get_user_type == 20 then
         if not Get_user_input[7] then
            CustomTypeData = gg.prompt({
               'Input The code from DUMP.CS file\nCopy from the class/struct name files and feilds\nproperties and methods not required ' })
         end
      end
   end
   error = 0
end

function O_initial_search()
   gg.setVisible(false)
   gg.toast("ğŸŸ¢ğ’ğ‹ğğ–ğ‚ğğŒ ğ’ğ‚ğ‘ğˆğğ“: ğ…ğ¢ğ«ğ¬ğ­ ğ“ğ«ğ²")
   user_input = ":" .. Get_user_input[1]
   if Get_user_input[3] then
      offst = 25
   else
      offst = 0
   end
end

function O_dinitial_search()
   if error > 1 then
      gg.setRanges(gg.REGION_C_ALLOC)
   else
      gg.setRanges(gg.REGION_OTHER)
   end
   gg.searchNumber(user_input, gg.TYPE_BYTE)
   count = gg.getResultsCount()
   if count == 0 then
      found_("O_dinitial_search")
      return 0
   end
   Refiner = gg.getResults(1)
   gg.refineNumber(Refiner[1].value, gg.TYPE_BYTE)
   count = gg.getResultsCount()
   if count == 0 then
      found_("O_dinitial_search")
      return 0
   end
   val = gg.getResults(count)
end

function CA_pointer_search()
   gg.clearResults()
   gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_OTHER | gg.REGION_ANONYMOUS)
   gg.loadResults(val)
   gg.searchPointer(offst)
   count = gg.getResultsCount()
   if count == 0 then
      found_("CA_pointer_search")
      return 0
   end
   val = gg.getResults(count)
end

function CA_apply_offset()
   if Get_user_input[4] then
      tanker = 0xfffffffffffffff8
   else
      tanker = 0xfffffffffffffff0
   end
   local copy = false
   local l = val

   for i, v in ipairs(l) do
      v.address = v.address + tanker
      if copy then v.name = v.name .. ' #2' end
   end
   val = gg.getValues(l)
end

function CA2_apply_offset()
   if Get_user_input[4] then
      tanker = 0xfffffffffffffff8
   else
      tanker = 0xfffffffffffffff0
   end
   local copy = false
   local l = val
   for i, v in ipairs(l) do
      v.address = v.address + tanker
      if copy then v.name = v.name .. ' #2' end
   end
   val = gg.getValues(l)
end

function Q_apply_fix()
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.loadResults(val)
   count = gg.getResultsCount()
   if count == 0 then
      found_("Q_apply_fix")
      return 0
   end
   yy = gg.getResults(1000)
   gg.clearResults()
   i = 1
   c = 1
   s = {}
   while (i - 1) < count do
      yy[i].address = yy[i].address + 0xb400000000000000
      gg.searchNumber(yy[i].address, gg.TYPE_QWORD)
      cnt = gg.getResultsCount()
      if 0 < cnt then
         bytr = gg.getResults(cnt)
         n = 1
         while (n - 1) < cnt do
            s[c] = {}
            s[c].address = bytr[n].address
            s[c].flags = 32
            n = n + 1
            c = c + 1
         end
      end
      gg.clearResults()
      i = i + 1
   end
   val = gg.getValues(s)
end

function A_base_value()
   gg.setRanges(gg.REGION_ANONYMOUS)
   gg.loadResults(val)
   gg.searchPointer(offst)
   count = gg.getResultsCount()
   if count == 0 then
      found_("A_base_value")
      return 0
   end
   val = gg.getResults(count)
end

function A_base_accuracy()
   gg.setRanges(gg.REGION_ANONYMOUS | gg.REGION_C_ALLOC)
   gg.loadResults(val)
   gg.searchPointer(offst)
   count = gg.getResultsCount()
   if count == 0 then
      found_("A_base_accuracy")
      return 0
   end
   kol = gg.getResults(count)
   i = 1
   h = {}
   while (i - 1) < count do
      h[i] = {}
      h[i].address = kol[i].value
      h[i].flags = 32
      i = i + 1
   end
   val = gg.getValues(h)
end

function IsComplexTypeChoosen()
   local Output
   Output = {}
   if (Get_user_type == gg.TYPE_BYTE or Get_user_type == gg.TYPE_DWORD or Get_user_type == gg.TYPE_QWORD or Get_user_type == gg.TYPE_FLOAT or Get_user_type == gg.TYPE_DOUBLE) then
      Output['IsComplex'] = false
   elseif (Get_user_type == 6) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector2"
   elseif (Get_user_type == 7) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector2Int"
   elseif (Get_user_type == 8) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector3"
   elseif (Get_user_type == 9) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector3Int"
   elseif (Get_user_type == 10) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector4"
   elseif (Get_user_type == 11) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Vector4Int"
   elseif (Get_user_type == 12) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "String"
   elseif (Get_user_type == 13) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Bounds"
   elseif (Get_user_type == 14) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "BoundsInt"
   elseif (Get_user_type == 15) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Matrix2x3"
   elseif (Get_user_type == 16) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Matrix4x4"
   elseif (Get_user_type == 17) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Color"
   elseif (Get_user_type == 18) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Color32"
   elseif (Get_user_type == 19) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "Quaternion"
   elseif (Get_user_type == 20) then
      Output['IsComplex'] = true
      Output['FeildHandler'] = "CustomFeild"
   end

   return Output
end

function A_user_given_offset()
   local old_save_list = val
   local uniqueTable = {} -- Table to hold unique addresses
   local addressSet = {}  -- Set to track seen addresses

   for _, item in ipairs(old_save_list) do
      if not addressSet[item.address] then
         table.insert(uniqueTable, item)
         addressSet[item.address] = true
      end
   end

   old_save_list = uniqueTable
 
   local finalResults = {}
   local finalResultIndex = 1
   local hex_values = {}
   local hexx_values = {}
   local complex_loaded_list = {}
   local TempComplexTypeStore = IsComplexTypeChoosen()
   if Get_user_input[7] then
      Get_user_input[2] = tostring(Get_user_input[2])
   end

   for hex in Get_user_input[2]:gmatch("0x%x+") do
      table.insert(hex_values, hex)
   end
   if Get_user_input[7] then
      Get_user_input[2] = '0x0'
   end


   -- Normal values loader, Loads dword or qword if basic type is not selected
   for i, v in ipairs(old_save_list) do
      for index, value in ipairs(hex_values) do
         if Get_user_input[7] then
            value = 0
         end

         finalResults[finalResultIndex] = {}
         finalResults[finalResultIndex].address = v.address + value
         if (SearchTypeSelection == 1) then
            if (TempComplexTypeStore['IsComplex']) then
               local ComplexTypeRefrence = { ['address'] = v.address + value }
               local TempSingleTypeLoad = ComplexFeildsHandlers[TempComplexTypeStore['FeildHandler']](
                  ComplexTypeRefrence)

               for i = 1, #TempSingleTypeLoad do
                  complex_loaded_list[#complex_loaded_list + 1] = TempSingleTypeLoad[i]
               end
            else
               finalResults[finalResultIndex].flags = Get_user_type
            end
         else
            if Get_user_input[4] then
               finalResults[finalResultIndex].flags = gg.TYPE_DWORD
            else
               finalResults[finalResultIndex].flags = gg.TYPE_QWORD
            end
         end
         finalResultIndex = finalResultIndex + 1
      end
   end
   if (SearchTypeSelection == 1) then
      if (TempComplexTypeStore['IsComplex']) then
         finalResults = gg.getValues(complex_loaded_list)
         Results = complex_loaded_list
         if SearchTypeSelection == 1 then
            if Get_user_input[6] then
               gg.addListItems(complex_loaded_list)
            end
         end
      else
         finalResults = gg.getValues(finalResults)
         Results = finalResults
      end
   end


   -- Struct values loader, It loades the struct values given during struct search mode
   if (SearchTypeSelection == 2) then
      for hex in Get_second_feild_offset[1]:gmatch("0x%x+") do
         table.insert(hexx_values, hex)
      end

      local structValues = {}
      local structValueIndex = 1;


      for i, v in ipairs(finalResults) do
         for index, value in ipairs(hexx_values) do
            if value == "0x0" then
               value = 0
            end
            if Get_user_input[7] then
               value = 0
            end

            structValues[structValueIndex] = {}
            structValues[structValueIndex].address = v.address + value
            if (TempComplexTypeStore['IsComplex']) then
               local ComplexTypeRefrence = { ['address'] = v.address + value }
               local TempSingleTypeLoad = ComplexFeildsHandlers[TempComplexTypeStore['FeildHandler']](
                  ComplexTypeRefrence)

               for i = 1, #TempSingleTypeLoad do
                  complex_loaded_list[#complex_loaded_list + 1] = TempSingleTypeLoad[i]
               end
            else
               structValues[structValueIndex].flags = Get_user_type
            end

            structValueIndex = structValueIndex + 1
         end
      end

      gg.clearResults()

      if (TempComplexTypeStore['IsComplex']) then
         structValues = gg.getValues(complex_loaded_list)
         Results = complex_loaded_list
         if SearchTypeSelection == 2 then
            if Get_user_input[6] then
               gg.addListItems(complex_loaded_list)
            end
         end
      else
         structValues = gg.getValues(structValues)
         Results = structValues
      end



      gg.loadResults(structValues)
   elseif (SearchTypeSelection == 3) then
      -- Child class loader, it loades child class from the offsets given by user

      finalResults = gg.getValues(finalResults)
      for hex in Get_second_feild_offset[1]:gmatch("0x%x+") do
         table.insert(hexx_values, hex)
      end



      local childClassValues = {}
      local childClassIndex = 1;

      -- Final result contains pointers
      -- final result val + offset will be new values to be loaded
      for i, v in ipairs(finalResults) do
         for index, value in ipairs(hexx_values) do
            if value == "0x0" then
               value = 0
            end
            childClassValues[childClassIndex] = {}
            childClassValues[childClassIndex].address = v.value + value


            -- From here code for custom load
            if (TempComplexTypeStore['IsComplex']) then
               local ComplexTypeRefrence = { ['address'] = v.value + value }
               local TempSingleTypeLoad = ComplexFeildsHandlers[TempComplexTypeStore['FeildHandler']](
                  ComplexTypeRefrence)

               for i = 1, #TempSingleTypeLoad do
                  complex_loaded_list[#complex_loaded_list + 1] = TempSingleTypeLoad[i]
               end
            else
               childClassValues[childClassIndex].flags = Get_user_type
            end



            childClassIndex = childClassIndex + 1
         end
      end

      gg.clearResults()
      if (TempComplexTypeStore['IsComplex']) then
         childClassValues = gg.getValues(complex_loaded_list)
         Results = complex_loaded_list
         if SearchTypeSelection == 3 then
            if Get_user_input[6] then
               gg.addListItems(complex_loaded_list)
            end
         end
      else
         childClassValues = gg.getValues(childClassValues)
         Results = childClassValues
      end
      gg.loadResults(childClassValues)
   else
      gg.clearResults()
      gg.loadResults(finalResults)
   end

   count = gg.getResultsCount()
   if count == 0 then
      found_("A_user_given_offset")
      return 0
   end
   gg.setVisible(true)
end

-- Function to parse the input string
function parseClass(input)
   -- Adjusted pattern to capture the class access modifier and name
   local classAccess, classType, className = input:match("(%w+) (class) (%w+)")
   if not type then
      classAccess, classType, className = input:match("(%w+) (struct) (%w+)")
   end

   if Get_user_input[7] then
      classType = "struct"
   end
   local fields = {}

   -- Pattern to match all relevant access modifiers and multi-word types
   local pattern = "(%w+) (%w+); // (0x%x+)"

   -- Use the pattern to find all matches
   for type, name, offset in input:gmatch(pattern) do
      -- Trim any leading or trailing whitespace from the type
      type = type:match("^%s*(.-)%s*$")
      table.insert(fields, { visibility = visibility, name = name, type = type, offset = offset })
   end

   return { classAccess = classAccess, classType = classType, className = className, fields = fields }
end

-- Integer Types:

-- int: 32-bit signed integer (4 bytes)
-- long: 64-bit signed integer (8 bytes)
-- short: 16-bit signed integer (2 bytes)
-- byte: 8-bit unsigned integer (1 byte)
-- uint: 32-bit unsigned integer (4 bytes)
-- ulong: 64-bit unsigned integer (8 bytes)
-- ushort: 16-bit unsigned integer (2 bytes)
-- sbyte: 8-bit signed integer (1 byte)
-- Floating-Point Types:

-- float: 32-bit single-precision floating point (4 bytes)
-- double: 64-bit double-precision floating point (8 bytes)
-- decimal: 128-bit high-precision decimal type (16 bytes)
-- Character Type:

-- char: 16-bit Unicode character (2 bytes)
-- Boolean Type:

-- bool: Implementation-defined size, but generally 1 byte (8 bits) in memory
-- String Type:

-- string: The size depends on the length of the string, but each character is 16 bits (2 bytes) due to being UTF-16 encoded.
-- Object Type:

-- object: The size of an object reference is platform-dependent: 4 bytes on a 32-bit system and 8 bytes on a 64-bit system, but the actual object data is the size of the contained data plus metadata overhead

function GetHandler(Input)
   for index, value in ipairs(Input['fields']) do
      if Input['fields'][index]['type'] == 'int' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_DWORD
         Input['fields'][index]['Name'] = "(int, 32 bit, signed)"
      elseif Input['fields'][index]['type'] == 'uint' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_DWORD
         Input['fields'][index]['Name'] = "(int, 32 bit, unsigned)"
      elseif Input['fields'][index]['type'] == 'short' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_WORD
         Input['fields'][index]['Name'] = "(short, 16 bit, signed)"
      elseif Input['fields'][index]['type'] == 'ushort' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_WORD
         Input['fields'][index]['Name'] = "(short, 16 bit, unsigned)"
      elseif Input['fields'][index]['type'] == 'bool' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_BYTE
         Input['fields'][index]['Name'] = "(bool, 8 bit, unsigned)"
      elseif Input['fields'][index]['type'] == 'byte' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_BYTE
         Input['fields'][index]['Name'] = "(byte, 8 bit, unsigned)"
      elseif Input['fields'][index]['type'] == 'ubyte' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_BYTE
         Input['fields'][index]['Name'] = "(byte, 8 bit, signed)"
      elseif Input['fields'][index]['type'] == 'float' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_FLOAT
         Input['fields'][index]['Name'] = "(Float, 32 bit)"
      elseif Input['fields'][index]['type'] == 'double' then
         Input['fields'][index]['handler'] = 'BasicType'
         Input['fields'][index]['BasicType'] = gg.TYPE_DOUBLE
         Input['fields'][index]['Name'] = "(Double, 32 bit)"
      elseif Input['fields'][index]['type'] == 'Vector2' then
         Input['fields'][index]['handler'] = 'Vector2'
      elseif Input['fields'][index]['type'] == 'Vector2Int' then
         Input['fields'][index]['handler'] = 'Vector2Int'
      elseif Input['fields'][index]['type'] == 'Vector3' then
         Input['fields'][index]['handler'] = 'Vector3'
      elseif Input['fields'][index]['type'] == 'Vector3Int' then
         Input['fields'][index]['handler'] = 'Vector3Int'
      elseif Input['fields'][index]['type'] == 'Vector4' then
         Input['fields'][index]['handler'] = 'Vector4'
      elseif Input['fields'][index]['type'] == 'Vector4Int' then
         Input['fields'][index]['handler'] = 'Vector4Int'
      elseif Input['fields'][index]['type'] == 'Bounds' then
         Input['fields'][index]['handler'] = 'Bounds'
      elseif Input['fields'][index]['type'] == 'BoundsInt' then
         Input['fields'][index]['handler'] = 'BoundsInt'
      elseif Input['fields'][index]['type'] == 'Matrix2x3' then
         Input['fields'][index]['handler'] = 'Matrix2x3'
      elseif Input['fields'][index]['type'] == 'Matrix4x4' then
         Input['fields'][index]['handler'] = 'Matrix4x4'
      elseif Input['fields'][index]['type'] == 'Color' then
         Input['fields'][index]['handler'] = 'Color'
      elseif Input['fields'][index]['type'] == 'Color32' then
         Input['fields'][index]['handler'] = 'Color32'
      elseif Input['fields'][index]['type'] == 'Quaternion' then
         Input['fields'][index]['handler'] = 'Quaternion'
      elseif Input['fields'][index]['type'] == 'string' then
         Input['fields'][index]['handler'] = 'String'
      else
         if Get_user_input[4] then
            Input['fields'][index]['handler'] = 'BasicType'
            Input['fields'][index]['BasicType'] = gg.TYPE_DWORD
            Input['fields'][index]['Name'] = "(Unidentified : Pointer if class, first value if struct)"
         else
            Input['fields'][index]['handler'] = 'BasicType'
            Input['fields'][index]['BasicType'] = gg.TYPE_QWORD
            Input['fields'][index]['Name'] = "(Unidentified : Pointer if class, first value if struct)"
         end
      end
   end

   return Input
end


function start()
   user_input_taker()
   O_initial_search()
   O_dinitial_search()
   if error > 0 then
      return 0
   end
   CA_pointer_search()
   if error > 0 then
      return 0
   end
   CA_apply_offset()
   if error > 0 then
      return 0
   end
   A_base_value()
   if error > 0 then
      return 0
   end
   if offst == 0 then
      A_base_accuracy()
   end
   if error > 0 then
      return 0
   end
   A_user_given_offset()
   if error > 0 then
      return 0
   end
   loopCheck()
   if error > 0 then
      return 0
   end
end

function second_start()
   gg.toast("ğŸŸ¡ğ’ğ‹ğğ–ğ‚ğğŒ ğ’ğ‚ğ‘ğˆğğ“: ğ’ğğœğ¨ğ§ğ ğ“ğ«ğ²")
   O_dinitial_search()
   if error > 1 then
      return 0
   end
   CA_pointer_search()
   if error > 1 then
      return 0
   end
   CA_apply_offset()
   if error > 1 then
      return 0
   end
   Q_apply_fix()
   if error > 1 then
      return 0
   end
   if offst == 0 then
      A_base_accuracy()
   end
   if error > 1 then
      return 0
   end
   A_user_given_offset()
   if error > 1 then
      return 0
   end
   loopCheck()
   if error > 1 then
      return 0
   end
end

function third_start()
   gg.toast("ğŸ”´ğ’ğ‹ğğ–ğ‚ğğŒ ğ’ğ‚ğ‘ğˆğğ“: ğ“ğ¡ğ¢ğ«ğ ğ“ğ«ğ²")
   O_dinitial_search()
   if error > 2 then
      return 0
   end
   CA_pointer_search()
   if error > 2 then
      return 0
   end
   if offst == 0 then
      CA2_apply_offset()
   end
   if error > 2 then
      return 0
   end
   A_base_value()
   if error > 2 then
      return 0
   end
   if offst == 0 then
      A_base_accuracy()
   end
   if error > 2 then
      return 0
   end
   A_user_given_offset()
   if error > 2 then
      return 0
   end
   loopCheck()
   if error > 2 then
      return 0
   end
end

function fourth_start()
   gg.toast("â˜¢ï¸ğ’ğ‹ğğ–ğ‚ğğŒ ğ’ğ‚ğ‘ğˆğğ“: ğ…ğ¨ğ®ğ«ğ­ğ¡ ğ“ğ«ğ²")
   O_dinitial_search()
   CA_pointer_search()
   CA2_apply_offset()
   Q_apply_fix()
   if offst == 0 then
      A_base_accuracy()
   end
   A_user_given_offset()
   loopCheck()
end

-- -- Float , float , float,
-- -- Player possition
--    -float
--    -float
--    -float
--    -- second
--       -float
--       -float
--       -float
--       -- third
--          -float
--          -float
--          -float



ComplexFeildsHandlers = {
   ['BasicType'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = Input['BasicType']
      Output[1].name = Input['Name']
      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
      end
      return Output
   end,
   ['Vector2'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Vector2 : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Vector2 : Y)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
      end

      return Output
   end,
   ['Vector2Int'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_DWORD
      Output[1].name = " (Vector2Int : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_DWORD
      Output[2].name = " (Vector2Int : Y)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
      end

      return Output
   end,
   ['Vector3'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Vector3 : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Vector3 : Y)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Vector3 : Z)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
      end

      return Output
   end,
   ['Vector3Int'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_DWORD
      Output[1].name = " (Vector3Int : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_DWORD
      Output[2].name = " (Vector3Int : Y)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_DWORD
      Output[3].name = " (Vector3Int : Z)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
      end

      return Output
   end,
   ['Vector4'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Vector4 : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Vector4 : Y)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Vector4 : Z)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_FLOAT
      Output[4].name = " (Vector4 : W)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
      end

      return Output
   end,
   ['Vector4Int'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_DWORD
      Output[1].name = " (Vector4Int : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_DWORD
      Output[2].name = " (Vector4Int : Y)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_DWORD
      Output[3].name = " (Vector4Int : Z)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_DWORD
      Output[4].name = " (Vector4Int : W)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
      end
      return Output
   end,
   ['Bounds'] = function(Input)
      local Output = {}
      local TempSingleTypeLoad = ComplexFeildsHandlers.Vector3(Input)
      for i = 1, #TempSingleTypeLoad do
         TempSingleTypeLoad[i].name = "Bounds : m_Center " .. TempSingleTypeLoad[i].name
         Output[#Output + 1] = TempSingleTypeLoad[i]
      end

      local TempSingleTypeLoad = ComplexFeildsHandlers.Vector3({ ['address'] = Input.address + 0xC })
      for i = 1, #TempSingleTypeLoad do
         TempSingleTypeLoad[i].name = "Bounds : m_Extents " .. TempSingleTypeLoad[i].name
         Output[#Output + 1] = TempSingleTypeLoad[i]
      end

      return Output
   end,
   ['BoundsInt'] = function(Input)
      local Output = {}
      local TempSingleTypeLoad = ComplexFeildsHandlers.Vector3Int(Input)
      for i = 1, #TempSingleTypeLoad do
         TempSingleTypeLoad[i].name = "BoundsInt : m_Center " .. TempSingleTypeLoad[i].name
         Output[#Output + 1] = TempSingleTypeLoad[i]
      end

      local TempSingleTypeLoad = ComplexFeildsHandlers.Vector3Int({ ['address'] = Input.address + 0xC })
      for i = 1, #TempSingleTypeLoad do
         TempSingleTypeLoad[i].name = "BoundsInt : m_Extents " .. TempSingleTypeLoad[i].name
         Output[#Output + 1] = TempSingleTypeLoad[i]
      end

      return Output
   end,
   ['Matrix2x3'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Matrix2x3 : m00)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Matrix2x3 : m01)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Matrix2x3 : m02)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_FLOAT
      Output[4].name = " (Matrix2x3 : m10)"

      Output[5] = {}
      Output[5].address = Input.address + 0x10
      Output[5].flags = gg.TYPE_FLOAT
      Output[5].name = " (Matrix2x3 : m11)"

      Output[6] = {}
      Output[6].address = Input.address + 0x14
      Output[6].flags = gg.TYPE_FLOAT
      Output[6].name = " (Matrix2x3 : m12)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
         Output[5].name = Input['name'] .. "  " .. Output[5].name
         Output[6].name = Input['name'] .. "  " .. Output[6].name
      end
      return Output
   end,
   ['Matrix4x4'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Matrix4x4 : m00)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Matrix4x4 : m10)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Matrix4x4 : m20)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_FLOAT
      Output[4].name = " (Matrix4x4 : m30)"

      Output[5] = {}
      Output[5].address = Input.address + 0x10
      Output[5].flags = gg.TYPE_FLOAT
      Output[5].name = " (Matrix4x4 : m01)"

      Output[6] = {}
      Output[6].address = Input.address + 0x14
      Output[6].flags = gg.TYPE_FLOAT
      Output[6].name = " (Matrix4x4 : m11)"

      Output[7] = {}
      Output[7].address = Input.address + 0x18
      Output[7].flags = gg.TYPE_FLOAT
      Output[7].name = " (Matrix4x4 : m21)"

      Output[8] = {}
      Output[8].address = Input.address + 0x1C
      Output[8].flags = gg.TYPE_FLOAT
      Output[8].name = " (Matrix4x4 : m31)"

      Output[9] = {}
      Output[9].address = Input.address + 0x20
      Output[9].flags = gg.TYPE_FLOAT
      Output[9].name = " (Matrix4x4 : m02)"

      Output[10] = {}
      Output[10].address = Input.address + 0x24
      Output[10].flags = gg.TYPE_FLOAT
      Output[10].name = " (Matrix4x4 : m12)"

      Output[11] = {}
      Output[11].address = Input.address + 0x28
      Output[11].flags = gg.TYPE_FLOAT
      Output[11].name = " (Matrix4x4 : m22)"

      Output[12] = {}
      Output[12].address = Input.address + 0x2C
      Output[12].flags = gg.TYPE_FLOAT
      Output[12].name = " (Matrix4x4 : m32)"

      Output[13] = {}
      Output[13].address = Input.address + 0x30
      Output[13].flags = gg.TYPE_FLOAT
      Output[13].name = " (Matrix4x4 : m03)"

      Output[14] = {}
      Output[14].address = Input.address + 0x34
      Output[14].flags = gg.TYPE_FLOAT
      Output[14].name = " (Matrix4x4 : m13)"

      Output[15] = {}
      Output[15].address = Input.address + 0x38
      Output[15].flags = gg.TYPE_FLOAT
      Output[15].name = " (Matrix4x4 : m23)"

      Output[16] = {}
      Output[16].address = Input.address + 0x3C
      Output[16].flags = gg.TYPE_FLOAT
      Output[16].name = " (Matrix4x4 : m33)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
         Output[5].name = Input['name'] .. "  " .. Output[5].name
         Output[6].name = Input['name'] .. "  " .. Output[6].name
         Output[7].name = Input['name'] .. "  " .. Output[7].name
         Output[8].name = Input['name'] .. "  " .. Output[8].name
         Output[9].name = Input['name'] .. "  " .. Output[9].name
         Output[10].name = Input['name'] .. "  " .. Output[10].name
         Output[11].name = Input['name'] .. "  " .. Output[11].name
         Output[12].name = Input['name'] .. "  " .. Output[12].name
         Output[13].name = Input['name'] .. "  " .. Output[13].name
         Output[14].name = Input['name'] .. "  " .. Output[14].name
         Output[15].name = Input['name'] .. "  " .. Output[15].name
         Output[16].name = Input['name'] .. "  " .. Output[16].name
      end

      return Output
   end,
   ['Color'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Color : Red)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Color : Blue)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Color : Green)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_FLOAT
      Output[4].name = " (Color : Opacity)"

      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
      end
      return Output
   end,
   ['Color32'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_BYTE
      Output[1].name = " (Color32 : Red)"

      Output[2] = {}
      Output[2].address = Input.address + 0x1
      Output[2].flags = gg.TYPE_BYTE
      Output[2].name = " (Color32 : Blue)"

      Output[3] = {}
      Output[3].address = Input.address + 0x2
      Output[3].flags = gg.TYPE_BYTE
      Output[3].name = " (Color32 : Green)"

      Output[4] = {}
      Output[4].address = Input.address + 0x3
      Output[4].flags = gg.TYPE_BYTE
      Output[4].name = " (Color32 : Opacity)"


      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
      end
      return Output
   end,
   ['Quaternion'] = function(Input)
      local Output = {}
      Output[1] = {}
      Output[1].address = Input.address
      Output[1].flags = gg.TYPE_FLOAT
      Output[1].name = " (Quaternion : X)"

      Output[2] = {}
      Output[2].address = Input.address + 0x4
      Output[2].flags = gg.TYPE_FLOAT
      Output[2].name = " (Quaternion : Y)"

      Output[3] = {}
      Output[3].address = Input.address + 0x8
      Output[3].flags = gg.TYPE_FLOAT
      Output[3].name = " (Quaternion : Z)"

      Output[4] = {}
      Output[4].address = Input.address + 0xC
      Output[4].flags = gg.TYPE_FLOAT
      Output[4].name = " (Quaternion : W)"


      if Input['name'] ~= nil then
         Output[1].name = Input['name'] .. "  " .. Output[1].name
         Output[2].name = Input['name'] .. "  " .. Output[2].name
         Output[3].name = Input['name'] .. "  " .. Output[3].name
         Output[4].name = Input['name'] .. "  " .. Output[4].name
      end
      return Output
   end,
   ['String'] = function(Input)
      local flags
      if Get_user_input[4] then
         flags = gg.TYPE_DWORD
      else
         flags = gg.TYPE_QWORD
      end

      Input.flags = flags

      local TableList = {}
      TableList[1] = Input

      Input = gg.getValues(TableList)[1]
      local Output = {}
      local offset
      if Get_user_input[4] then
         offset = 0x8
      else
         offset = 0x10
      end
      StringLength = gg.getValues({ [1] = { ['address'] = Input.value + offset, ['flags'] = gg.TYPE_DWORD } })

      if StringLength[1].value < 0 then
         StringLength[1].value = 0
      elseif StringLength[1].value > 1000 then
         StringLength[1].value = 1000
      end

      for i = 1, StringLength[1].value * 2 + 1 do
         if i == 1 then
            Output[i] = { ['address'] = Input.value + offset, ['flags'] = gg.TYPE_DWORD }
         else
            Output[i] = {}
            Output[i].flags = gg.TYPE_BYTE
            Output[i].address = Input.value + offset + 0x3 + (i - 0x1)
         end
      end

      Output = gg.getValues(Output)


      FullString = ''

      for i = 1, #Output do
         local currentChar

         if Output[i].value < 0 or Output[i].value > 255 then
            currentChar = '*Invalid char*'
         else
            currentChar = string.char(Output[i].value)
         end
         if i ~= 1 then
            FullString = FullString .. currentChar
            Output[i].name = ' (String : Char no ' .. i - 1 .. ', Char : ' .. currentChar .. ')'
         end
      end
      Output[1].name = ' (Int :String length : ' .. Output[1].value .. ', Full string : ' .. FullString .. ')';

      return Output
   end,
   ['CustomFeild'] = function(Input)
      local complex_loaded_list = {}
      local PointerValue
      if Get_user_input[4] then
         PointerValue = gg.getValues({ [1] = { ['address'] = Input.address, ['flags'] = gg.TYPE_DWORD } })
      else
         PointerValue = gg.getValues({ [1] = { ['address'] = Input.address, ['flags'] = gg.TYPE_QWORD } })
      end

      if Get_user_input[7] then
         ClassParsedInTable = parseClass(tostring(CustomLoadData))
         ParsedClassWithHandlers = GetHandler(ClassParsedInTable)
      else
         ClassParsedInTable = parseClass(tostring(CustomTypeData))
         ParsedClassWithHandlers = GetHandler(ClassParsedInTable)
      end
      for index, value in ipairs(ParsedClassWithHandlers['fields']) do
         if ParsedClassWithHandlers['classType'] == 'class' then
            if Get_user_input[4] then
               ParsedClassWithHandlers['fields'][index].address = PointerValue[1].value +
                   ParsedClassWithHandlers['fields'][index].offset
            else
               ParsedClassWithHandlers['fields'][index].address = PointerValue[1].value +
                   ParsedClassWithHandlers['fields'][index].offset
            end
         else
            if ParsedClassWithHandlers['fields'][index].offset == "0x0" then
               ParsedClassWithHandlers['fields'][index].offset = 0
            else
               -- ParsedClassWithHandlers['fields'][index].offset = tonumber(ParsedClassWithHandlers['fields'][index].offset, 10)
            end
            ParsedClassWithHandlers['fields'][index].address = Input.address +
                ParsedClassWithHandlers['fields'][index].offset
         end
         local TempSingleTypeLoad = ComplexFeildsHandlers[ParsedClassWithHandlers['fields'][index].handler](
            ParsedClassWithHandlers['fields'][index])

         for i = 1, #TempSingleTypeLoad do
            complex_loaded_list[#complex_loaded_list + 1] = TempSingleTypeLoad[i]
         end
      end

      return complex_loaded_list
   end

}


function UI()
   gg.showUiButton()
   while true do
      if gg.isClickedUiButton() then
         start()
      end
   end
end

function stopClose()
   while true do
      mainMenu()
      gg.setVisible(false)
      while gg.isVisible() == false do
      end
   end
end

if userMode == 2 then
   stopClose()
else
   UI()
end










